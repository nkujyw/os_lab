#### 练习1: 完成读文件操作的实现（需要编码）

首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，填写在 kern/fs/sfs/sfs_inode.c中 的sfs_io_nolock()函数，实现读文件中数据的代码。







#### 练习2: 完成基于文件系统的执行程序机制的实现（需要编码）

改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行`exit`, `hello`（更多用户程序放在`user`目录下）等其他放置在`sfs`文件系统中的其他执行程序，则可以认为本实验基本成功。







#### 扩展练习 Challenge1：完成基于“UNIX的PIPE机制”的设计方案

如果要在ucore里加入UNIX的管道（Pipe）机制，至少需要定义哪些数据结构和接口？（接口给出语义即可，不必具体实现。数据结构的设计应当给出一个（或多个）具体的C语言struct定义。在网络上查找相关的Linux资料和实现，请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，你的设计应当体现出对可能出现的同步互斥问题的处理。）







#### 扩展练习 Challenge2：完成基于“UNIX的软连接和硬连接机制”的设计方案

如果要在ucore里加入UNIX的软连接和硬连接机制，至少需要定义哪些数据结构和接口？（接口给出语义即可，不必具体实现。数据结构的设计应当给出一个（或多个）具体的C语言struct定义。在网络上查找相关的Linux资料和实现，请在实验报告中给出设计实现”UNIX的软连接和硬连接机制“的概要设方案，你的设计应当体现出对可能出现的同步互斥问题的处理。）

#### 1. 总体设计思路

在 ucore 的 Simple File System (SFS) 中引入 UNIX 风格的链接机制，主要是将文件系统的**目录树结构**与**物理数据存储**分开，即让文件名只是一个标签，文件数据归文件数据存。这样，一份数据就可以贴好几个不同的标签（硬链接），或者一个标签指向另一个标签（软链接）。。

- **硬链接 (Hard Link)**：利用索引节点（Inode）的**引用计数**机制，允许不同的目录项指向同一个 Inode。
- **软链接 (Symbolic Link)**：引入一种新的文件类型，其数据块中存储的内容不再是普通数据，而是指向另一个文件的**路径字符串**。

#### 2. 数据结构设计

根据 SFS 文件系统的定义（参考 `sfs.h`），实现链接机制需要利用以下核心数据结构。

##### 2.1 磁盘索引节点设计 (`struct sfs_disk_inode`)

这是文件元数据在磁盘上的结构。主要是复用 `nlinks` 字段和扩展 `type` 字段。

```c
struct sfs_disk_inode {
    uint32_t size;                  // 文件大小
    uint16_t type;                  // 文件类型
    uint16_t nlinks;                // 硬链接计数
    uint32_t blocks;                // 块数量
    uint32_t direct[SFS_NDIRECT];   // 直接索引
    uint32_t indirect;              // 间接索引
};
```

- **`nlinks`**：用于硬链接计数。创建文件时初始化为 1。每增加一个硬链接，该值 +1。每删除一个硬链接，该值 -1。只有当 `nlinks == 0` 且内存中无进程引用时，才回收该 inode。
- **`type`**：用于标识软链接。 `type == SFS_TYPE_LINK` 时，系统将该文件的数据块内容解释为路径。

##### 2.2 内存文件系统控制块 (`struct sfs_fs`)

用于管理文件系统全局状态，主要是用同步互斥的锁。

```c
struct sfs_fs {
    // ... 其他字段 ...
    semaphore_t mutex_sem;          // 文件系统级互斥锁
    // ...
};
```

- **`mutex_sem`**：一个大粒度的互斥锁。设计要求在进行涉及目录结构变更的操作（如 `link`, `unlink`, `rename`）时必须持有此锁，以维护目录树的一致性。

##### 2.3 内存索引节点 (`struct sfs_inode`)

用于内存中的文件操作。

```C
struct sfs_inode {
    struct sfs_disk_inode *din;     // 对应的磁盘 inode
    // ...
    semaphore_t sem;                //Inode 级读写锁
};
```

- **`sem`**：用于保护单个 Inode 的内部数据。在修改 `nlinks` 计数时用此锁。

------

#### 3. 接口设计与语义

需要在 VFS 层与 SFS 层之间定义以下操作接口。

##### 3.1 硬链接接口: `vop_link`

在指定目录 `dir` 下创建一个名为 `name` 的新目录项，使其直接指向源节点 `node` 对应的 Inode。它不分配新 Inode，仅增加源 Inode 的 `nlinks` 计数。

- **参数**：
  - `dir`: 目标目录的 Inode。
  - `name`: 新链接的文件名。
  - `node`: 被链接的源文件 Inode。
- **返回值**：0 表示成功，非 0 表示错误码（如目标已存在、源为目录等）。

##### 3.2 软链接接口: `vop_symlink`

在指定目录 `dir` 下创建一个名为 `name` 的新文件，其类型为 `SFS_TYPE_LINK`，内容为 `path` 字符串。它分配新 Inode，分配数据块，将 `path` 写入数据块。

- **参数**：
  - `dir`: 目标目录的 Inode。
  - `name`: 软链接的文件名。
  - `path`: 软链接指向的目标路径。

##### 3.3 读软链接接口: `vop_readlink`

读取软链接文件 `node` 中存储的路径信息。像读普通文件一样读取数据块内容，但仅供系统路径解析使用。

- **参数**：
  - `node`: 软链接文件的 Inode。
  - `iob`: 用于回传数据的 I/O 缓冲区。

##### 3.4 删除链接接口: `vop_unlink`

从目录 `dir` 中移除名为 `name` 的目录项，并递减对应 Inode 的硬链接计数。如果递减后 `nlinks == 0`，则标记该 Inode 待回收。

------

#### 4. 概要设计方案

##### 4.1 硬链接操作流程

1. **检查合法性**：检查源节点是否为目录。
2. **并发保护**：锁定文件系统 (`lock_sfs_fs`) 和源节点 (`lock_sin`)。
3. **更新元数据**：将源 Inode 的 `nlinks` 加 1，并标记 Inode 为 Dirty。
4. **创建目录项**：在目标目录的数据块中写入 `(name, source_ino)` 映射。
5. **落盘**：将修改后的 Inode 和目录块写回磁盘。

##### 4.2 软链接操作流程

1. **创建节点**：分配一个新的 Inode，设置 `type = SFS_TYPE_LINK`。
2. **写入数据**：将目标路径字符串作为文件内容写入 Inode 关联的数据块。
3. **建立映射**：在父目录中创建目录项指向这个新 Inode。
4. **路径解析修改**：修改 VFS 的 `lookup` 逻辑，当遇到 `SFS_TYPE_LINK` 时，触发 `vop_readlink` 读取路径并插入当前解析序列。

##### 4.3 删除链接 (Unlink) 与资源回收流程

1. **删除映射**：在父目录中删除对应的文件名条目。
2. **递减计数**：对应文件的 Inode `nlinks` 减 1。
3. **条件回收**：
   - 若 `nlinks > 0`：仅更新 Inode 并保存。
   - 若 `nlinks == 0`：检查内存引用计数 (`reclaim_count`)。如果也为 0，则释放该 Inode 及其占用的所有数据块（Bitmap 位置 1）。

------

#### 5. 同步互斥问题的处理

在多进程操作系统中，文件系统操作必须具备原子性，否则可能导致文件丢失或文件系统损坏。本设计采用**两级锁机制**：

##### 5.1 第一级：文件系统锁 (`sfs_fs.mutex_sem`)

用于保护目录树结构的一致性。即在执行 `link`、`symlink`、`unlink` 的最外层操作中，持有 `sfs->mutex_sem`。确保目录项的增删和 Inode 的查找是一个原子过程。
**应用场景**：

  - 防止“A 进程正在目录下创建链接”的同时，“B 进程删除了该目录”。
  - 防止“A 进程正在链接文件 X”的同时，“B 进程删除了文件 X”。


##### 5.2 第二级：索引节点锁 (`sfs_inode.sem`)

用于保护单个文件元数据（特别是 `nlinks`）的一致性。即在修改 `sin->din->nlinks` 字段前后，必须持有 `sin->sem`。
**应用场景**： 防止两个进程同时对同一个文件创建硬链接，导致 `nlinks` 计算错误（例如两个进程读到 1，都写回 2，实际应为 3）。

##### 5.3 死锁预防

用以下的严格的层级加锁顺序可以有效避免 AB-BA 类型的死锁。

- **加锁顺序**：严格遵守 **先获取 FS 级锁，再获取 Inode 级锁** 的顺序。
- **解锁顺序**：严格遵守 **先释放 Inode 级锁，再释放 FS 级锁** 的顺序。



