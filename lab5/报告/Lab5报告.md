# 用户程序实验报告
## 练习1: 加载应用程序并执行（需要编码）
do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。

请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。


## 练习2: 父进程复制自己的内存空间给子进程（需要编码）
**创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。**

**请在实验报告中简要说明你的设计实现过程。**

**如何设计实现Copy on Write机制？给出概要设计，鼓励给出详细设计。**

### 1.copy_range函数实现

```c
            void *src_kvaddr = page2kva(page);
            void *dst_kvaddr = page2kva(npage);
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
            ret = page_insert(to, npage, start, perm);
```

在 `copy_range` 函数中，按**页大小**对父进程的用户虚拟地址空间进行复制。

对于每一个需要复制的用户页，首先为子进程**新分配一个物理页**。随后通过 `page2kva` 将父进程对应的物理页以及新分配的物理页转换为内核虚拟地址，使内核可以直接访问这两块内存。

接着使用 `memcpy` 将父进程页面中的内容完整拷贝到子进程的新页面中，最后调用 `page_insert`，在子进程页表中建立虚拟地址到该物理页的映射，并沿用父进程的访问权限。

### 2.Copy on Write机制设计


Copy on Write 是一种**延迟内存复制**的机制，其核心思想是：**在进程创建时不立即复制物理页面，而是在发生写操作时才进行复制**。通过该机制，可以显著减少不必要的内存拷贝，提高系统性能和内存利用率。

接下来我将给出详细设计过程：

#### 1. fork 阶段

在本实验中，我们需要在 `do_fork / copy_range` 阶段引入 Copy on Write 机制，不再为子进程立即分配新的物理页并复制内容，而是采用**共享映射**的方式完成地址空间的建立。

具体而言，我需要让父进程和子进程的页表项同时指向同一个物理页，并清除页表项中的写权限位，同时设置软件定义的 `PTE_COW` 标志位，用于标识该页面为写时复制页面。

此外，我还需要对该物理页的引用计数进行增加，以准确反映其被多个进程共享的状态。


#### 2. 页表项与权限设计

为了支持写时复制机制，我还需要对参与 COW 的页表项进行了统一的权限设计。每个 COW 页面对应的页表项均满足以下特征：页面有效（`PTE_V`）、允许用户态访问（`PTE_U`），但不包含写权限位（`PTE_W`），并额外设置 `PTE_COW` 标志。

#### 3. 写时触发

在进程运行过程中，当某个进程尝试对 COW 页面进行写访问时，由于该页面在页表中被标记为只读，CPU 会自动触发页保护异常并进入内核态。此时，我们在 Page Fault 处理函数中对异常原因进行判断，确认其为写访问导致的异常，并进一步检查对应页表项是否被标记为 `PTE_COW`。

只有在上述条件均满足的情况下，系统才会执行写时复制流程，从而保证普通只读页和非法访问不会被误处理为 COW 情况。

#### 4.真正复制页面

在 Page Fault 处理函数中，我需要根据物理页的共享情况采取不同的处理策略。首先获取当前页表项所指向的原物理页 `old_page`，并检查其引用计数。

当引用计数大于 1 时，说明该页面仍被多个进程共享。此时，我们为当前进程分配新的物理页 `new_page`，并将 `old_page` 中的内容完整复制到 `new_page`。随后更新当前进程的页表项，使其指向新分配的物理页，并恢复写权限，同时清除 `PTE_COW` 标志；原物理页的引用计数相应减一。

当引用计数等于 1 时，说明该页面已经不再被其他进程共享。我们无需再进行页面复制，只需直接为该页恢复写权限并清除 `PTE_COW` 标志即可。最后，我们刷新 TLB，以确保页表修改能够立即生效。

#### 5. 页面释放与回收

在进程退出或解除地址空间映射时，我还需要对相关物理页的引用计数进行递减。当某个物理页的引用计数降为 0 时，系统将其回收并释放对应的物理内存。



## 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：

- 请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
- 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）

在本实验中，fork/exec/wait/exit 这几个系统调用的共同模式是：用户态通过库函数发起系统调用，利用 ecall 指令触发陷入，CPU 进入内核态后，在 trap 处理函数中根据系统调用号分发到对应的内核实现（sys_fork/sys_exec/sys_wait/sys_exit），这些函数再调用 do_fork/do_execve/do_wait/do_exit 完成实际的进程管理工作，最后由内核修改当前进程的 trapframe（特别是保存返回值的寄存器和返回地址 epc），通过 sret 返回到用户态。从用户程序视角看，它只是调用了一个普通的 C 函数，获得一个返回值；但在这期间，CPU 实际在用户态和内核态之间完成了一次完整的上下文切换和资源操作。以 fork 为例，用户态调用库函数 fork（或者 sys_fork），在 user/libs/syscall.c 中统一通过 syscall() 把系统调用号装入寄存器 a0，参数装入 a1 等，然后执行一条 ecall。这一步是纯用户态的工作。ecall 执行后，硬件把用户态的 pc 保存到 sepc，记录陷入原因到 scause，切到内核栈并跳转到 trap 入口。汇编入口代码把所有通用寄存器保存到当前进程的内核栈上，形成 struct trapframe，然后调用 C 函数 trap(struct trapframe *tf)。在 trap 中，根据 tf->cause 判断是用户态系统调用（CAUSE_USER_ECALL），把 tf->epc 加 4（跳过 ecall 指令本身），再调用 syscall()。syscall() 从 tf->gpr.a0 里取出系统调用号，从 a1~a5 中取出参数，查系统调用表，调到 sys_fork，由它继续调用 do_fork。do_fork 在内核态完成：分配子进程的 proc_struct，分配子进程内核栈，复制或共享父进程的地址空间（创建新的 mm 和页表，复制父进程的页表项和物理页映射），设置父子关系和新的 pid，把子进程插入到全局进程链表和就绪队列中，构造子进程的线程上下文和 trapframe，使得子进程第一次被调度执行时，从 fork 调用之后的用户态指令开始执行，并且在子进程的 trapframe 中将 a0 设为 0。do_fork 自身返回的是子进程 pid，内核把这个返回值写回当前进程的 trapframe 中的 a0。之后 trap 收尾，汇编部分从 trapframe 中恢复寄存器，执行 sret 回到用户态。这样父进程在用户态看到 fork() 返回子进程 pid，而子进程在第一次被调度时，从同一条 fork 调用之后的指令开始执行，看到的返回值为 0。这说明内核态的执行结果是通过修改 trapframe 中寄存器的值（尤其是返回值寄存器和 epc）返回给用户程序的。

exit 的执行流程与之类似，但方向相反。用户态调用 exit(code) 后，通过 ecall 进入内核，进入 sys_exit，再调用 do_exit(code)。在 do_exit 中，首先会防御性地检查不能退出某些特殊进程，随后切换到内核页表，释放当前进程的用户态地址空间，包括销毁 mm、取消页表映射等，然后把当前进程的状态设为 PROC_ZOMBIE，记录退出码 exit_code，必要时调整子进程的父指针（例如交给 init），并唤醒正在等待该进程的父进程。最后调用 schedule() 切换走，do_exit 不再返回到用户态。也就是说，调用 exit 的进程在内核中完成清理之后，其生命周期从运行态转入僵尸态，之后只有父进程通过 wait 调用来回收它，调用 exit 的那一段用户代码不会再继续执行。

wait 的主要作用是让父进程在内核中等待子进程结束并回收子进程资源。用户态调用 wait(&code)，通过 ecall 进入内核，系统调用分发后进入 do_wait(pid, code_store)。在 do_wait 中，内核先利用 user_mem_check 等机制检查 code_store 是否是合法的用户空间地址，然后遍历进程表，寻找以当前进程为父进程的子进程。如果找到一个状态为 PROC_ZOMBIE 的子进程，就把该子进程的 exit_code 写入到用户传入的 code_store 指向的内存中，释放该子进程的内核栈和 PCB，把它从进程链表中移除，最后返回该子进程的 pid。如果发现有子进程存在，但它们尚未退出，则当前进程会把自己的状态设为 PROC_SLEEPING，设置等待原因（例如等待子进程结束），然后调用 schedule() 主动放弃 CPU，直到将来被唤醒。子进程在 do_exit 中设置自身为 PROC_ZOMBIE 后，会调用 wakeup_proc(parent) 唤醒父进程，父进程再次被调度回来继续执行 do_wait 中的循环，直至找到僵尸状态的子进程并完成回收。最后，do_wait 返回子进程 pid，syscall() 将该 pid 写入 trapframe 的 a0，sret 返回用户态，用户进程中的 wait() 函数就以这个值作为返回结果。

exec 是在当前进程内部替换用户态程序的系统调用。用户态调用 exec 后进入内核，经过系统调用分发进入 do_execve(name, len, binary, size)。在 do_execve 中，内核首先检查程序名和参数字符串的用户地址合法性，然后释放当前进程原有的用户地址空间和页表，创建新的 mm，解析 ELF 格式的可执行文件，根据程序头为各个段分配物理页，并建立新的页表映射，拷贝代码和数据段到新地址空间，设置新的用户栈。随后修改当前进程 trapframe 中的 epc 为新程序的入口地址，修改 sp 为新栈顶。形式上，do_execve 返回一个整数值（通常 0 表示成功，负值表示错误），syscall() 仍将其写入 a0，但从本质上，sret 返回用户态时，用户态地址空间和 epc 已经完全切换到新程序，相当于原有的用户程序被新程序取代，后续执行的是新程序的第一条指令，而不是原先调用 exec 的那段代码。这说明在 exec 的情况下，内核通过修改 trapframe 中的 epc、sp 和页表，使得控制流从“旧程序”无缝转到“新程序”。

从宏观上看，内核态与用户态的程序执行是通过 trap 机制交错进行的：用户态顺序执行，遇到系统调用、中断或异常时，硬件和汇编入口负责从用户态切换到内核态，构造 trapframe；内核代码在 trapframe 的基础上检查 cause，执行对应的处理逻辑，可能改变当前进程的状态、页表和 trapframe 内容，也可能调用 schedule() 切换到其他进程；最后某个要继续在用户态执行的进程，其 trapframe 被恢复，内核通过 sret 把控制权交还给用户态。系统调用的返回值、返回地址以及进程状态的变化，都是通过对 trapframe 和 proc_struct 中字段的修改体现出来的。

在进程状态生命周期方面，ucore 使用 enum proc_state 定义了进程的若干状态，包括 PROC_UNINIT（尚未完全初始化的进程）、PROC_RUNNABLE（可被调度执行的进程，包含就绪状态和当前正在运行状态）、PROC_SLEEPING（在内核中因等待某个事件而睡眠）、PROC_ZOMBIE（已经调用了 exit，释放了大部分资源，仅保留退出码等少量信息，等待父进程 wait）。

字符图如下：
```text
                       创建与初始化
        alloc_proc / proc_init / do_fork
                           |
                           v
                     +-------------+
                     | PROC_UNINIT |
                     +-------------+
                           |
        完成 mm / 页表 / 内核栈 / 上下文 等初始化
                           |
                           v
                     +--------------+
                     | PROC_RUNNABLE|<-------------------+
                     +--------------+                    |
                           |                             |
             schedule 选中  |                            |
             → proc_run    |                             |
                           v                             |
                      [Running]                          |
          （可能在用户态，也可能在内核态）                   |
                            |                            |
      do_sleep / do_wait 等 |                            |
      阻塞当前进程，调用      |                            |
      schedule              |                            |
                           v                             |
                     +--------------+                    |
                     | PROC_SLEEPING|------------------+
                     +--------------+   wakeup_proc /
                           ^            事件到达等
                           |
                           |
   do_exit（exit 系统调用）
   在内核中释放资源、记录退出码等
                           |
                           v
                     +--------------+
                     | PROC_ZOMBIE  |
                     +--------------+
                           |
         父进程在 do_wait 中找到该子进程，
         读取 exit_code，释放 PCB/内核栈
                           |
                           v
                       （被销毁）
```
make grade结果如下：               
![make grade](c31578a1cd1a0c16d5e474654934d4ef.jpg)

## 扩展练习 Challenge

### 1.实现 Copy on Write （COW）机制

给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。

这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在ucore操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在ucore中实现这样的COW机制。

由于COW实现比较复杂，容易引入bug，请参考 https://dirtycow.ninja/ 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。

这是一个big challenge.

### 2.说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

#### ucore加载方式

在 uCore 中,用户程序**并不是在运行时从磁盘加载的**，而是在内核编译与链接阶段，就已经被作为二进制数据打包进内核镜像中，并随内核一起被加载到内存。

具体过程是：

1. 位于 `user/` 目录下的用户程序（如 `exit.c`）会在 **编译阶段** 被单独编译链接成 ELF 可执行文件；
    
2. 这些 ELF 文件通过 `objcopy` 等工具转换为二进制数据；
    
3. 链接器为每个用户程序生成符号，如：
    
    `_binary_obj___user_exit_out_start _binary_obj___user_exit_out_size`
    
4. 内核在启动时，整个内核镜像包括这些用户程序的二进制数据**一次性被加载到内存中**；
    
5. 当内核线程 `user_main` 调用 `kernel_execve()` 时，  
    内核只是从内存中的这段二进制数据解析 ELF 并建立用户态地址空间，并未发生磁盘 I/O。
    
因此，用户程序在系统启动时就已经“预先存在于内存中”。

#### 常用操作系统的加载方式

常用的 Unix/Linux 操作系统中，用户程序是在运行时通过 `execve()` 从磁盘加载。当用户在 Shell 中执行一个程序时，内核会：

1. 通过文件系统（VFS）查找可执行文件；
2. 从磁盘将 ELF 文件内容读入内存；
3. 在 `execve()` 过程中按需建立进程的地址空间，并通过按页加载方式映射代码段和数据段；
4. 随后切换到用户态开始执行程序。

uCore 采用用户程序预加载到内存的方式，主要是为了简化实验实现。

在当前阶段尚未引入完整的文件系统和磁盘驱动，若在运行时从磁盘加载程序会显著增加系统复杂度。通过将用户程序直接嵌入内核镜像，`execve()` 可以专注于 ELF 加载、地址空间建立和用户态切换等核心机制，同时避免磁盘 I/O 和按需加载对实验理解的干扰。

